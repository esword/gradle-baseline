/*
 * (c) Copyright 2019 Palantir Technologies Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.palantir.baseline.tasks.dependencies;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.collect.Streams;
import com.paypal.digraph.parser.GraphParser;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.concurrent.ThreadSafe;
import org.apache.maven.shared.dependency.analyzer.ClassAnalyzer;
import org.apache.maven.shared.dependency.analyzer.DefaultClassAnalyzer;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.ConfigurationContainer;
import org.gradle.api.artifacts.ModuleDependency;
import org.gradle.api.artifacts.ResolvedArtifact;
import org.gradle.api.file.Directory;

/**
 * Parses dot files generated by jdeps and groups dependencies them into useful categories:
 * * required - those used by classes listed in the dot files
 * * api - those used in the API of the given classes.
 * * implicit - used but not declared in the given set of configurations.  Does not flag dependencies that are
 *      declared in a parent configuration.  e.g. If a project lists a dependency as an implementation dependency
 *      and then also uses that dependency in test classes, it does not have to declare the dependency in the
 *      testImplementation config as well.
 * * unused - declared but not used.  Unlike with the implicit dependency calculation, a dependency must be declared
 *      directly in the provided configurations in order for it to be considered unused.  This is to avoid the opposite
 *      of the situation for implicit dependencies - e.g. If a project includes a dependency as part of it's main
 *      configurations and then does not use it in test sources, it should not be reported as unused when reporting on
 *      the test sources.
 */
public final class DependencyAnalyzer {
    private static final ClassAnalyzer JAR_ANALYZER = new DefaultClassAnalyzer();
    private static final ImmutableSet<String> VALID_ARTIFACT_EXTENSIONS = ImmutableSet.of("jar", "");

    private final Project project;
    private final Set<String> configurations;
    private final Directory dotFileDir;

    private Set<String> allRequiredDependencies;
    private Set<String> apiDependencies;
    private Set<String> implicitDependencies;
    private Set<String> unusedDependencies;

    private final Indexes indexes = new Indexes();

    public DependencyAnalyzer(
            Project project,
            Set<String> configurations,
            Directory dotFileDir) {
        this.project = project;

        this.configurations = configurations;
        this.dotFileDir = dotFileDir;
    }

    /**
     * Full list of dependencies that are required by the project.
     */
    public Set<String> getAllRequiredDependencies() {
        return allRequiredDependencies;
    }

    /**
     * Dependencies used in project's APIs - public or protected methods, public static methods, superclasses, etc.
     * See jdeps documentation for more info on what it considers to be in an API.
     */
    public Set<String> getApiDependencies() {
        return apiDependencies;
    }

    /**
     * Dependencies that are required but are not directly declared by the project.
     */
    public Set<String> getImplicitDependencies() {
        return implicitDependencies;
    }

    /**
     * Dependencies that are declared in one of the given configurations but not used in byte code.  This will only
     * report on dependencies that are directly listed by the given configurations.  It is possible that a dependency
     * is used in a source-only annotation or through some other generation tool.
     */
    public Set<String> getUnusedDependencies() {
        return unusedDependencies;
    }

    public void analyze() {
        ConfigurationContainer configContainer = project.getConfigurations();
        Set<Configuration> configs = configurations.stream()
                .map(configContainer::findByName)
                .filter(c -> c != null)
                .collect(Collectors.toSet());

        indexes.populateIndexes(configs);

        allRequiredDependencies = findReferencedDependencies(DependencyUtils.findDetailedDotReport(dotFileDir));
        apiDependencies = findReferencedDependencies(DependencyUtils.findDetailedDotReport(dotFileDir.dir("api")));
        Set<String> declaredDependencies = getDependencyIds(configs, false);
        Set<String> directlyDeclaredDependencies = getDependencyIds(configs, true);

        implicitDependencies = Sets.difference(allRequiredDependencies, declaredDependencies);
        unusedDependencies = Sets.difference(declaredDependencies, allRequiredDependencies).stream()
                .filter(a -> directlyDeclaredDependencies.contains(a))
                .collect(Collectors.toSet());

        //clear the memory from the massive dependency map
        indexes.reset();
    }

    /**
     * Returns dependencies declared in the given configurations, optionally including those declared by parent
     * configurations.  Does not include transitive dependencies.
     */
    private static Set<String> getDependencyIds(Collection<Configuration> configurations, boolean directOnly) {
        return configurations.stream()
                .flatMap(d -> (directOnly ? d.getDependencies() : d.getAllDependencies()).stream())
                .filter(ModuleDependency.class::isInstance)
                .map(ModuleDependency.class::cast)
                .map(DependencyUtils::getDependencyName)
                .collect(Collectors.toSet());
    }

    private Set<String> findReferencedDependencies(Optional<File> dotFile) {
        return Streams.stream(dotFile)
                .flatMap(this::findReferencedClasses)
                .map(indexes::classToDependency)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toSet());
    }

    /**
     * Return all classes that are referenced (i.e. depended upon) by classes in the given dot file.
     */
    private Stream<String> findReferencedClasses(File dotFile) {
        try (InputStream input = new FileInputStream(dotFile)) {
            GraphParser parser = new GraphParser(input);
            return parser.getEdges()
                    .values()
                    .stream()
                    .map(e -> e.getNode2().getId())
                    .map(DependencyAnalyzer::cleanNodeName);
        } catch (IOException e) {
            throw new RuntimeException("Unable to analyze " + dotFile, e);
        }
    }

    /**
     * Strips excess junk written by jdeps.
     */
    private static String cleanNodeName(String name) {
        return name.replaceAll(" \\([^)]*\\)", "").replace("\"", "");
    }

    @ThreadSafe
    public static final class Indexes {
        private final Map<String, String> classToDependency = new ConcurrentHashMap<>();

        public void populateIndexes(Collection<Configuration> configurations) {
            Collection<ResolvedArtifact> allArtifacts = getResolvedArtifacts(configurations);

            allArtifacts.forEach(artifact -> {
                try {
                    File jar = artifact.getFile();

                    Set<String> classesInArtifact = JAR_ANALYZER.analyze(jar.toURI().toURL());
                    classesInArtifact.forEach(clazz -> classToDependency.put(clazz,
                            DependencyUtils.getDependencyName(artifact)));
                } catch (IOException e) {
                    throw new RuntimeException("Unable to analyze artifact", e);
                }
            });
        }

        /** Given a class, returns what dependency brought it in if known. */
        public Optional<String> classToDependency(String clazz) {
            return Optional.ofNullable(classToDependency.get(clazz));
        }

        public void reset() {
            classToDependency.clear();
        }

        /**
         * All artifacts with valid extensions (i.e. jar) from the configuration dependencies, including
         * transitives.  Artifact identifiers are unique for hashing, so can return a set.
         *
         * TODO: Perhaps try to use Configuration.incoming.artifacts.artifacts rather than the old API
         */
        private Set<ResolvedArtifact> getResolvedArtifacts(Collection<Configuration> configurations) {
            return configurations.stream()
                    .filter(Configuration::isCanBeResolved)
                    .map(Configuration::getResolvedConfiguration)
                    .flatMap(resolved -> resolved.getFirstLevelModuleDependencies().stream())
                    .flatMap(dependency -> dependency.getAllModuleArtifacts().stream())
                    .filter(a -> VALID_ARTIFACT_EXTENSIONS.contains(a.getExtension()))
                    .collect(Collectors.toSet());
        }

    }

}
